package pami.com.pamiimport android.graphics.Colorimport android.graphics.Typefaceimport android.graphics.Typeface.BOLDimport android.os.Bundleimport android.support.v4.app.Fragmentimport android.view.Gravityimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.*import io.reactivex.disposables.CompositeDisposableimport kotlinx.android.synthetic.main.fragment_shifts.*import pami.com.pami.models.Shiftimport java.text.SimpleDateFormatimport java.util.*class SaleriesFragment : Fragment() {    private lateinit var prevBtn: LinearLayout    private lateinit var nextBtn: LinearLayout    private lateinit var progressBar: ProgressBar    private var monthTv: TextView? = null    private var calendar: Calendar = Calendar.getInstance()    private var table: TableLayout? = null    private var shifts = mutableListOf<Shift>()    private var simpleDateFormat = SimpleDateFormat("MMMM yyyy", Locale("swe"))    private var simpleDateFormat2 = SimpleDateFormat("yyyyMM", Locale("swe"))    private var simpleDateFormat3 = SimpleDateFormat("HH:mm", Locale("swe"))    private var selectedDate = Date()    private lateinit var salaryView: TextView    private lateinit var pdfBtn: ImageButton    private lateinit var salarySpecifications: MutableList<SalarySpecification>    private  var disposable = CompositeDisposable()    companion object {        fun getInstance(): SaleriesFragment {            return SaleriesFragment()        }    }    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {        val view = inflater.inflate(R.layout.fragment_shifts, container, false)        this.prevBtn = view.findViewById(R.id.prev_btn)        this.nextBtn = view.findViewById(R.id.next_btn)        this.progressBar = view.findViewById(R.id.indeterminateBar)        monthTv = view.findViewById(R.id.month_TV)        table = view.findViewById(R.id.tableLayout)        this.salaryView = view.findViewById(R.id.salary_tv)        this.pdfBtn = view.findViewById(R.id.pdf_btn)        val dis1 = FirebaseController.getSalarySpec().subscribe {            this.salarySpecifications = it        }        this.pdfBtn.setOnClickListener { _ ->            val dateKey = simpleDateFormat2.format(this.selectedDate)            this.salarySpecifications.forEach { spec ->                if (spec.id == dateKey) {                    this.progressBar.visibility = View.VISIBLE                    FirebaseController.getPdf(spec, activity!!).subscribe {                        this.progressBar.visibility = View.GONE                    }                }            }        }        this.selectedDate = Date()        monthTv?.text = this.simpleDateFormat.format(this.selectedDate)        val dis2 = FirebaseController.getAcceptedShifts().subscribe {            this.shifts = it            this.shifts = Shared.sortShifts(this.shifts)            setUpTable()        }        this.disposable.addAll(dis1,dis2)        prevBtn.setOnClickListener { view2 -> handleDateChange(view2) }        nextBtn.setOnClickListener { view3 -> handleDateChange(view3) }        return view    }    private fun setUpTable() {        this.pdf_btn.visibility = View.GONE        this.table?.removeAllViewsInLayout()        var totalNetto = 0.0        var totalDuration = 0.0        var totalBrutto = 0.0        val row = TableRow(context)        row.setBackgroundColor(Color.LTGRAY)        val tableHeaderViews = mutableListOf<TextView>()        val dayHeaderTV = TextView(context)        val startHeaderTV = TextView(context)        val endHeaderTV = TextView(context)        val durationHeaderTV = TextView(context)        val payHeaderTV = TextView(context)        dayHeaderTV.text = getString(R.string.dayColumn)        startHeaderTV.text = getString(R.string.startColumn)        endHeaderTV.text = getString(R.string.endColumn)        durationHeaderTV.text = getString(R.string.durationColumn)        payHeaderTV.text = getString(R.string.currency)        tableHeaderViews.add(dayHeaderTV)        tableHeaderViews.add(startHeaderTV)        tableHeaderViews.add(endHeaderTV)        tableHeaderViews.add(durationHeaderTV)        tableHeaderViews.add(payHeaderTV)        tableHeaderViews.forEach {            it.textSize = 16F            it.typeface = Typeface.MONOSPACE            it.gravity = Gravity.CENTER            it.setTextColor(Color.WHITE)            row.addView(it)        }        val calendar = Calendar.getInstance()        calendar.time = selectedDate        row.setBackgroundResource(R.drawable.bg_table_header_row)        row.setPadding(0, 30, 0, 30)        this.table?.addView(row)        shifts.forEach {            val startCal = Calendar.getInstance()            val endCal = Calendar.getInstance()            startCal.time = it.startDate            endCal.time = it.endDate            if (startCal.get(Calendar.MONTH) == calendar.get(Calendar.MONTH) && startCal.get(Calendar.YEAR) == calendar.get(Calendar.YEAR)) {                totalNetto += it.netto                totalDuration += it.duration                totalBrutto += it.brutto                val row2 = TableRow(context)                val tableCells: MutableList<TextView> = mutableListOf()                val dayTV = TextView(context)                val startTV = TextView(context)                val endTV = TextView(context)                val durationTV = TextView(context)                val payTV = TextView(context)                payTV.gravity = Gravity.END                dayTV.setTypeface(Typeface.MONOSPACE, BOLD)                dayTV.text = String.format("%02d", startCal.get(Calendar.DATE))                startTV.text = simpleDateFormat3.format(startCal.time)                endTV.text = simpleDateFormat3.format(endCal.time)                durationTV.text = it.duration.toString()//                payTV.text = it.netto.toString()                payTV.text = String.format("%.0f", it.netto)                tableCells.add(dayTV)                tableCells.add(startTV)                tableCells.add(endTV)                tableCells.add(durationTV)                tableCells.add(payTV)                tableCells.forEach { cell ->                    cell.gravity = Gravity.CENTER                    cell.textSize = 15F                    cell.typeface = Typeface.MONOSPACE                    row2.addView(cell)                }                row2.setBackgroundResource(R.drawable.bg_bottom_border_gray)                row2.setPadding(0, 50, 0, 50)                this.table?.addView(row2)            }        }        val lastRow = TableRow(context)        val totalCell = TextView(context)        totalCell.text = ""        totalCell.setTypeface(Typeface.MONOSPACE, BOLD)        totalCell.setTextColor(Color.BLACK)        totalCell.setBackgroundResource(R.drawable.bg_bottom_border_gray)        totalCell.setPadding(0, 50, 0, 50)        totalCell.gravity = Gravity.CENTER        this.salaryView.text = String.format("%.0f sek", totalBrutto)        val totalDurationCell = TextView(context)        totalDurationCell.text = totalDuration.toString()        totalDurationCell.setTypeface(Typeface.MONOSPACE, BOLD)        totalDurationCell.setTextColor(Color.BLACK)        totalDurationCell.gravity = Gravity.CENTER        totalDurationCell.setBackgroundResource(R.drawable.bg_bottom_border_gray)        totalDurationCell.setPadding(0, 50, 0, 50)        lastRow.addView(TextView(context))        lastRow.addView(TextView(context))        lastRow.addView(TextView(context))        lastRow.addView(totalDurationCell)        lastRow.addView(totalCell)        this.table?.addView(lastRow)        this.salarySpecifications.forEach {            val dateKey = this.simpleDateFormat2.format(this.selectedDate)            if (it.id == dateKey) {                this.pdf_btn.visibility = View.VISIBLE                val nettoRow = TableRow(context)                val nettoName = TextView(context)                nettoName.text = getString(R.string.netto)                nettoName.setTypeface(Typeface.MONOSPACE, BOLD)                nettoName.setTextColor(Color.BLACK)                nettoName.setBackgroundResource(R.drawable.bg_bottom_border_gray)                nettoName.setPadding(0, 50, 0, 50)                nettoName.gravity = Gravity.CENTER                val nettoValue = TextView(context)                nettoValue.text = it.netto.toString()                nettoValue.setTypeface(Typeface.MONOSPACE, BOLD)                nettoValue.setTextColor(Color.BLACK)                nettoValue.gravity = Gravity.CENTER                nettoValue.setBackgroundResource(R.drawable.bg_bottom_border_gray)                nettoValue.setPadding(0, 50, 0, 50)                nettoRow.addView(TextView(context))                nettoRow.addView(TextView(context))                nettoRow.addView(TextView(context))                nettoRow.addView(nettoName)                nettoRow.addView(nettoValue)                this.table?.addView(nettoRow)                return@forEach            }        }    }    private fun handleDateChange(view: View?) {        var fix = 0        if (view == prevBtn) {            fix = -1        }        if (view == nextBtn) {            fix = 1        }        calendar.add(Calendar.MONTH, fix)        this.selectedDate = calendar.time        monthTv?.text = simpleDateFormat.format(this.selectedDate)        setUpTable()    }    override fun onDestroy() {        this.disposable.dispose()        super.onDestroy()    }}